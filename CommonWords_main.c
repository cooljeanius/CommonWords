/*
 * Eric Gallager
 *
 * Assignment:
 * 
 * 2. Find common words and print them on output file!
 * 
 * Input: 
 * The input file, called the “input.dat”a , which contains the list of words with their length.
 * 
 * For example,
 * 
 *	6 foofoo
 *	10 blargblarg
 *	12 csci049isfun
 *	4 moom
 *	0
 *	4 moom
 *	6 doggod
 *	6 f34rm3
 *	6 foofoo
 *	0 
 * 
 * Output:
 * The output file, called the “output.dat”a , which contains your output (common words of input lists) 
 * 
 * For example,
 * 
 * foofoo
 * moom
 *
 * --- 
 * 
 * Algorithm:
 * 
 * 1. Make a struct for the combination of words and their length
 * 2. Make functions for handling i/o with this new struct
 * 3. Make a function for comparing structs
 *	3a. Compare lengths
 *	3b. If lengths are equal, strcmp the strings
 * 4. Put it all together
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h> // for strcmp() function 

#define STRING_MAX_LENGTH 100
#define MAX_NUMBER_OF_WORDS 11 // this is hard-coded because I can't get EOF detection working properly

typedef struct {
	int number_of_letters;
	char word[STRING_MAX_LENGTH];
	int number_of_matches;
} word_t;

/*
 * Displays a word
 */
void print_word(word_t word, FILE*outfilep); // prototype
void 
print_word(word_t word, FILE*outfilep) {
	if ((word.number_of_letters != 0) && (word.number_of_letters != EOF)) {
		fprintf((FILE*)outfilep, "%i %s \n", word.number_of_letters, word.word);
		printf("%i %s \n", word.number_of_letters, word.word); // Statement for debugging, so output.dat doesn't have to be opened each time
	} else {
		fprintf((FILE*)outfilep, "%i \n", word.number_of_letters);
		printf("%i \n", word.number_of_letters); // Statement for debugging, so output.dat doesn't have to be opened each time
	}
}

/*
 * Gets a word from a file
 */
word_t scan_word(FILE*infilep); // prototype
word_t 
scan_word(FILE*infilep) {
	word_t word;
	// printf("\n EOF = %i \n", EOF); // statement for debugging
	fscanf((FILE*)infilep, "%i", &word.number_of_letters);
	if ((word.number_of_letters != EOF) && (word.number_of_letters != 0)) {
		fscanf((FILE*)infilep, "%s", word.word);
	}
	/*
	 * The following loop doesn't actually do anything, but it doesn't hurt to keep it in, so why not
	 */
	if (word.word == NULL) {
		word.word[0] = ' ';
		fopen("input.dat", "w");
		fprintf((FILE*)infilep, "_"); // so it stops repeating scanning that one line
		fclose(infilep);
	}
	return (word);
}

/* 
 * Tests for same words
 * Return Values:
 *	0 => equal
 *	anything else => not equal
 *	1 => default return value (falls under the "not equal" set)
 */
int compare_words(word_t word1, word_t word2); // prototype
int
compare_words(word_t word1, word_t word2) {
	int ret_value = 1; // initialize to something other than 0 because 0 is what it returns on equality, and the null hypothesis is that of inequality
	if (word1.number_of_letters == word2.number_of_letters) { // only compare words with the same number of letters
		ret_value = strcmp(word1.word, word2.word); // returns 0 if equal
	}
	return(ret_value);
}

/*
 * Main function
 */
int main (int argc, const char * argv[]) { // generated by template
	FILE *infilep;
	infilep = fopen("input.dat", "r"); 
	if (infilep == NULL) { // check for existence of input file
		printf("\n Cannot open input.dat for input, make sure this file exists. \n");
	} else {
		printf("\n input.dat is good to go. \n");
	}
	FILE *outfilep;
	outfilep = fopen("output.dat", "w");
	word_t words[MAX_NUMBER_OF_WORDS]; // array for putting words in
	int i = 0; // initialize loop-counter
    printf("\n Message for security and/or debugging: \n This program's path is %s and it is running with %i argument(s). \n", argv[0], argc); // Statement for debugging
	printf("\n The contents of your file are: \n \f \n");
	for (i = 1; i < MAX_NUMBER_OF_WORDS; i++) { // goes through array for holding words in
		if (words[i].number_of_letters != EOF) {
			words[i] = scan_word(infilep);
			print_word(words[i], outfilep);
		}
		// printf("\n i = %i \n", i); // Statement for debugging
	}
	i--;
	// printf("\n i = %i \n", i); // Statement for debugging
	int j = 0;
	int k = 0; // we're going to need some more loop-counters
	int results[i][i]; // output array
	for (j = 1; j < i; j++) { // i is what the previous loop got up to
		for (k = 1; k < i; k++) {
			results[j][k] = 0; // initialize each array element
		}
	}
	for (j = 1; j < i; j++) { // do a separate loop so the results array won't get over-written
		words[j].number_of_matches = 1; // initialize
		for (k = 1; k < i; k++) {
			if (j != k) { // we don't want to be comparing things to themselves
				results[j][k] = results[j][k] + compare_words(words[j], words[k]);
				// printf("\n results[j][k] (i.e. results[%i][%i]) = %i \n", j, k, results[j][k]); // Statement for debugging
				results[k][j]++; // increment the other one to handle the associative property
				if (results[j][k] == 0) {
					words[j].number_of_matches++; // only need to increment one of them because they're the same thing
					printf("\n %s appears %i times. \n", words[j].word, words[j].number_of_matches);
					fprintf((FILE*)outfilep, "\n %s appears %i times. \n", words[j].word, words[j].number_of_matches); // put results into file
					results[k][j]++; // increment the other one to handle the associative property
				}
			}
		}
	}
	fclose(infilep); // finish up cleanly
	fclose(outfilep); // finish up cleanly
    return 0;
}

// newline \n

